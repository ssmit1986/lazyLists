(* Wolfram Language Package *)

(* Created by the Wolfram Workbench 18-Sep-2018 *)

BeginPackage["lazyLists`"]
(* Exported symbols added here with SymbolName::usage *) 

lazyList::usage = "lazyList is linked list data structure that should contain 2 elements: the first is the first element, the second a held expression that will generate the next linked list when evaluated.
You can extract these elements explicitely with First and Last/Rest. Part and Take will not work because they have been overloaded with special functionalities when used on lazyList.
lazyList[list] or lazyList[Hold[var]] is a special constructor that generates a lazyList from an ordinary list";

lazyRange::usage = "lazyRange[] is a lazy representation of the Integers from 1 to \[Infinity]. lazyRange[min, delta] represents values values from min onwards in steps of delta.
lazyRange has no upper limit and is generally slightly faster than lazyGenerator";

lazyPowerRange::usage = "lazyPowerRange[min, r] is the infinite list {min, r \[Times] min, r^2 \[Times] min, ...}";

lazyNestList::usage = "lazyNestList[f, elem] is the infinite list {elem, f[elem], f[f[elem]], ...} starting with elem and generated by iterating f repeatedly";

lazyStream::usage = "lazyStream[streamObject] creates a lazyList that streams from streamObject. These streams will stop automatically when EndOfFile is reached";

lazyConstantArray::usage = "lazyConstantArray[elem] produces an infinite list of copies of elem";

lazyTuples::usage = "lazyTuples is a lazy version of Tuples";
bulkExtractElementsUsingIndexList::usage = "bulkExtractElementsUsingIndexList[lists, indices] converts elements from Tuples[Range /@ Length /@ lists] into elements from Tuples[lists]";
rangeTuplesAtPositions::usage = "rangeTuplesAtPositions[Length /@ lists] is a CompiledFunction that directly generates elements of Tuples[Range /@ Length /@ lists]";

lazyMapThread::usage = "lazyMapThread[f, {lz1, lz2, ...}] is similar to MapThread, except all elements from the lazyLists are fed to the first slot of f as a regular List";

lazyTranspose::usage = "lazyTranspose[{lz1, lz2, ...}] creates a lazyList with tuples of elements from lz1, lz2, etc. 
Equivalent to lazyMapThread[Identity, {lz1, lz2, ...}]";

lazyPartMap::usage = "lazyPartMap[l, {i, j, k, ...}] is equivalent to Map[Part[l, {#}]&, {i, j, k, ...}] but faster";

lazyFinitePart::usage = "lazyFinitePart[lz, i, j, k,...] directly extracts Part from finite and periodic lazyLists without having to traverse the lazyList element-by-element. 
It is equivalent to Part[list, i, j, k, ...]";

lazyFiniteTake::usage = "lazyFiniteTake[lz, spec] directly applies Take to finite lazyLists and periodic lazyLists without having to traverse the lazyList element-by-element. 
It is equivalent to Take[list, spec]";

lazySetState::usage = "lazySetState[lz, state] with lz a supported lazyList returns a lazyList at the specified state. 
Finite lists, lazyPeriodicList, lists generated with lazyGenerator, lazy(Power)Range, and lazyNestList are supported.
Maps over supported lists are also supported";

lazyGenerator::usage = "lazyGenerator[f, start, min, max, step] generates a lazyList that applies f to values {start, start + step, start + 2 step, ...} for values between min and max (which are allowed to be infinite).
When min and max are both infinite, symbolic values for start and step are allowed";

lazyPeriodicList::usage = "lazyPeriodicList[list] is an infinite lazyList that cycles through the values in list periodically";

$lazyIterationLimit::usage = "Iteration limit used for finding successive elements in a lazy list";

Begin["`Private`"]
(* Implementation of the package *)

$lazyIterationLimit = Infinity;

Attributes[lazyList] = {HoldRest};

lazyList[list_List] := Module[{
    listVar = list
},
    lazyList[Hold[listVar]]
];

Attributes[lazyFiniteList] = {HoldFirst};
lazyList[Hold[list_Symbol]] := lazyFiniteList[list, 1];

With[{
    msgs = {Part::partw}
},
    (* Don't test patterns for performance. It's up to the user to make sure nothing illegal ends up in lazyFiniteList if they decide to use it *)
    lazyFiniteList[list_, i_] := Quiet[
        Check[
            lazyList[list[[i]], lazyFiniteList[list, i + 1]], 
            lazyList[],
            msgs
        ],
        msgs
    ]
];

lazySetState[lazyList[_, l : lazyFiniteList[list_, _]], index_Integer] /; 0 < index <= Length[list] :=
    lazyFiniteList[list, index];

lazySetState[l : lazyList[_, lazyFiniteList[list_, _]], index_Integer] /; -Length[list] <= index < 0 := 
    lazySetState[l, index + Length[list] + 1];

lazySetState[l : lazyList[_, lazyFiniteList[list_, _]], index_Integer] := (
    Message[Part::partw, index, Short[l]];
    l
);

lazyGenerator::badSpec = "Cannot create lazyGenerator with specifications `1`. Empty lazyList was returned";
lazyGenerator[
    f_,
    start : _ : 1,
    min : _ : DirectedInfinity[-1], max : _ : DirectedInfinity[1], step : _ : 1
] := Replace[
    Switch[ {min, max, start, step},
        {DirectedInfinity[-1], DirectedInfinity[1], __},
            twoSidedGenerator[f, start, step],
        {DirectedInfinity[-1], _?NumericQ, _?NumericQ, _?NumericQ},
            leftSidedGenerator[f, start, max, step],
        {_?NumericQ, DirectedInfinity[1], _?NumericQ, _?NumericQ},
            rightSidedGenerator[f, start, min, step],
        {_?NumericQ, _?NumericQ,_?NumericQ, _?NumericQ},
            finiteGenerator[f, start, min, max, step],
        _,
            lazyList[]
    ],
    {
        lazyList[] :> (
            Message[
                lazyGenerator::badSpec,
                AssociationThread[{"min", "max", "start", "step"}, {min, max, start, step}]
            ];
            lazyList[]
        )
    }
];

twoSidedGenerator[f_, pos_, step_] := lazyList[
    f[pos],
    twoSidedGenerator[f, pos + step, step]
];

leftSidedGenerator[f_, pos_, max_, step_] /; pos <= max := lazyList[
    f[pos],
    leftSidedGenerator[f, pos + step, max, step]
];
leftSidedGenerator[___] := lazyList[];

rightSidedGenerator[f_, pos_, min_, step_] /; min <= pos := lazyList[
    f[pos],
    rightSidedGenerator[f, pos + step, min, step]
];
rightSidedGenerator[___] := lazyList[];

finiteGenerator[f_, pos_, min_, max_, step_] /; Between[pos, {min, max}] := lazyList[
    f[pos],
    finiteGenerator[f, pos + step, min, max, step]
];
finiteGenerator[___] := lazyList[];

generatorPattern = Alternatives[twoSidedGenerator, leftSidedGenerator, rightSidedGenerator, finiteGenerator];

With[{ (* pattern needs to be With'ed in because of the HoldRest attribute of lazyList *)
    patt = generatorPattern
},
    lazySetState[
        l : lazyList[
            _,
            (gen : patt)[f_, pos_, rest___]
        ],
        state_
    ] := Replace[
        Check[gen[f, state, rest], $Failed],
        {
            Except[lazyList[_, _]] :> (Message[Part::partw, state, Short[l]]; l)
        }
    ]
];


(* For efficiency reasons, these lazy list generatorss are defined by self-referential anynomous functions. Note that #0 refers to the function itself *)
lazyRange[start : _ : 1, step : _ : 1] /; !TrueQ[step == 0] := Function[
    lazyList[#1, #0[#2 + #1, #2]]
][start, step];

lazyRange[start_, step_ /; TrueQ[step == 0]] := lazyConstantArray[start];

lazyPowerRange[start_, r_ /; !TrueQ[r == 1]] := Function[
    lazyList[#1, #0[#2 * #1, #2]]
][start, r];

lazyPowerRange[min_, r_ /; TrueQ[r == 1]] := lazyConstantArray[min]

lazyNestList[f_, elem_] := Function[
    lazyList[
        #1,
        #0[f[#1], #2 + 1]
    ]
][elem, 1];

(*lazySetState definition for lazyRange and lazyPowerRange and lazyNestList *)
lazySetState[
    lazyList[_, (f : Function[lazyList[#1, #0[_, _]]])[_, step_]],
    state_
] := f[state, step];

lazyStream[stream_InputStream] := Function[
    With[{
        read = Read[#1]
    },
        lazyList[
            read,
            If[ read =!= EndOfFile,
                #0[#1, #2 + 1], (* Increase an iterator to make sure that ReplaceRepeated in Take doesn't stop *)
                lazyList[] (* return an empty lazyList to end stream *)
            ]
        ]
    ]
][stream, 1];

lazyConstantArray[const_] := Function[
    lazyList[
        const,
        (* Increase an iterator to make sure that ReplaceRepeated in Take doesn't stop *)
        #0[#1 + 1]
    ]
][1];


Attributes[lazyPeriodicListInternal] = {HoldFirst};
lazyPeriodicListInternal[list_, i_, max_] := lazyList[
    list[[i]],
    lazyPeriodicListInternal[list, Mod[i, max] + 1, max]
];

lazyPeriodicList[list_List] := Module[{
    listVar = list
},
    lazyPeriodicList[Hold[listVar]]
];
lazyPeriodicList[Hold[list_Symbol]] := lazyPeriodicListInternal[list, 1, Length[list]];

lazySetState[lazyList[_, lazyPeriodicListInternal[list_, _, max_]], index_Integer] := 
    lazyPeriodicListInternal[list, Mod[index - UnitStep[index], max] + 1, max];

lazySetState::notSupported = "lazySetState is not supported for lazyList `1`";
lazySetState[l_lazyList, _] := (Message[lazySetState::notSupported, Short[l]]; l)


lazyList::notFinite = "lazyList `1` cannot be recognised as a finite list";

lazyFinitePart[lazyList[_, (lazyFiniteList | lazyPeriodicListInternal)[list_, __]], spec__] := Part[list, spec];
lazyFinitePart[l_lazyList, _] := (Message[lazyList::notFinite, Short[l]]; $Failed);

lazyFiniteTake[lazyList[_, (lazyFiniteList | lazyPeriodicListInternal)[list_, __]], spec_] := Take[list, spec];
lazyFiniteTake[l_lazyList, _] := (Message[lazyList::notFinite, Short[l]]; $Failed);

lazyPartMap[l_lazyList, indices : {__Integer}] := Module[{
    sortedIndices = Sort[indices]
},
    Part[
        FoldList[
            Function[
                Part[#1, {#2}]
            ],
            Part[l, sortedIndices[[{1}]]],
            Differences[sortedIndices] + 1
        ],
        Ordering[indices]
    ]
];

lazyMapThread[f_, list : {lazyList[_, _]..}] := lazyList[
    f[list[[All, 1]]],
    lazyMapThread[f, list[[All, 2]]]
];

lazyMapThread[_, _] := lazyList[];

lazyTranspose[list : {__lazyList}] := lazyMapThread[Identity, list];

(* Source of decompose and basis: https://mathematica.stackexchange.com/a/153609/43522 *)
basis[lengths : {__Integer}] := Reverse[
    FoldList[Times, 1, Reverse @ Rest @ lengths]
];

decompose = Compile[{
    {n, _Integer},
    {d, _Integer, 1}
}, 
    Module[{
        c = n - 1, (* I pick an offset here to make sure that n enumerates from 1 instead of 0 *)
        q
    },
        1 + Table[ (* And added 1 so it's not necessary to do so later on *)
            q = Quotient[c, i];
            c = Mod[c, i];
            q,
            {i, d}
        ]
    ],
    RuntimeAttributes -> {Listable}
];

rangeTuplesAtPositions[lengths : {__Integer}] := With[{
    b = basis[lengths]
},
    rangeTuplesAtPositions[lengths] = Compile[{
        {n, _Integer}
    },
        decompose[n, b],
        RuntimeAttributes -> {Listable},
        CompilationOptions -> {"InlineExternalDefinitions" -> True}
    ]
];

(* lazyList that generates the elements of Tuples[Range /@ lengths] *)
Options[indexLazyList] = {
    "StepSize" -> 1,
    "Start" -> 1
};
indexLazyList[lengths : {__Integer}, opts : OptionsPattern[]] := With[{
    start = Replace[OptionValue["Start"], Except[_Integer] :> 1],
    step = Replace[OptionValue["StepSize"], Except[_Integer] :> 1]
},
    lazyGenerator[
        rangeTuplesAtPositions[lengths],
        start, 1, Times @@ lengths, step
    ]
];

(* Helper function for lazyTuples[elements] *)
extractSpecFromIndexList = Compile[{
    {ind, _Integer, 1}
},
    Module[{i = 1},
        Table[{i++, n}, {n, ind}]
    ],
    RuntimeAttributes -> {Listable}
];

Options[lazyTuples] = Options[indexLazyList];
lazyTuples[
    elementLists_List | Hold[elementLists_Symbol],
    opts : OptionsPattern[]
] /; MatchQ[elementLists, {{__}..}] := Map[
    Extract[
        elementLists,
        extractSpecFromIndexList[#]
    ]&,
    indexLazyList[Length /@ elementLists, opts]
];

(* Helper function for lazyTuples[elements, tupLength] *)
extractSpecFromIndexTuples = Compile[{
    {indices, _Integer, 1}
},
    Transpose[{indices}],
    RuntimeAttributes -> {Listable}
];

lazyTuples[
    elementList_List,
    tupLength_Integer?Positive,
    opts : OptionsPattern[]
] /; MatchQ[elementList, Range @ Length @ elementList] := indexLazyList[ConstantArray[Length[elementList], tupLength], opts];

lazyTuples[
    elementList_List | Hold[elementList_Symbol],
    tupLength_Integer?Positive,
    opts : OptionsPattern[]
] /; MatchQ[elementList, {__}] := Map[
    Extract[
        elementList,
        extractSpecFromIndexTuples[#]
    ]&,
    indexLazyList[ConstantArray[Length[elementList], tupLength], opts]
];

(* Effectively equal to lazyTuples[Range /@ lengths] *)
lazyTuples[lengths : {__Integer}, opts : OptionsPattern[]] := indexLazyList[lengths, opts];

(* 
    Converts elements from 
    Tuples[Range /@ elements /@ elementLists]
    to elements from 
    Tuples[elementLists]
*)
bulkExtractElementsUsingIndexList[
    elementLists_List | Hold[elementLists_Symbol],
    indices_List | Hold[indices_Symbol]
] /; And[
    MatrixQ[indices, IntegerQ],
    Length[elementLists] === Dimensions[indices][[2]]
] := Partition[
    Extract[elementLists, Catenate[extractSpecFromIndexList[indices]]],
    Length[elementLists]
];


(* 
    Converts elements from 
    Tuples[Range @ Length @ elementLists], tupLength]
    to elements from 
    Tuples[elementLists, tupLength]
*)
bulkExtractElementsUsingIndexList[
    elementList_List | Hold[elementList_Symbol],
    indices_List | Hold[indices_Symbol],
    tupLength_Integer
] /; And[
    MatrixQ[indices, IntegerQ],
    tupLength === Dimensions[indices][[2]]
] := Partition[
    Extract[elementList, Catenate[extractSpecFromIndexTuples[indices]]],
    tupLength
];

End[]

EndPackage[]

